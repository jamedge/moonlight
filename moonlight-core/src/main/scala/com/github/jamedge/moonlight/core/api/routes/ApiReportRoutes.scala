package com.github.jamedge.moonlight.core.api.routes

import java.time.ZonedDateTime

import akka.actor.ActorSystem
import akka.http.scaladsl.model.headers.Accept
import akka.http.scaladsl.model.{ContentTypes, HttpEntity, HttpResponse, MediaTypes, StatusCodes}
import akka.http.scaladsl.server.{Directives, MalformedHeaderRejection, Route}
import com.github.jamedge.moonlight.core.api.ApiConfig
import com.github.jamedge.moonlight.core.api.versioning.HTMLGenerator
import com.github.jamedge.moonlight.core.api.versioning.line.LineHTMLSupport.generateLineHTML
import com.github.jamedge.moonlight.core.api.versioning.line.{LineMDGenerator, LineRoutesSupport}
import com.github.jamedge.moonlight.core.service.line.LineService

import scala.concurrent.duration._
import scala.concurrent.{Await, ExecutionContext, Future}

class ApiReportRoutes(
    lineService: LineService,
    apiConfig: ApiConfig
) (
    implicit val executionContext: ExecutionContext,
    actorSystem: ActorSystem,
    lineMDGenerator: LineMDGenerator,
    htmlGenerator: HTMLGenerator
) extends Directives with LineRoutesSupport {

  def routes: Route = {
    report
  }

  private[routes] def report: Route = {
    path("report") {
      get {
        headerValueByType[Accept]() { accept =>
          if (accept.mediaRanges.exists(_.matches(MediaTypes.`text/html`))) { // TODO: add separate report in Markdown
            complete(HttpResponse(
              StatusCodes.OK,
              entity = HttpEntity(
                ContentTypes.`text/html(UTF-8)`,
                Await.result(getLinesHtml(), apiConfig.routesLoadTimeoutsMs.report.milliseconds))
            ))
          } else {
            reject(MalformedHeaderRejection("Accept", s"Provided value: ${accept.value()}. Supported values: 'text/html'.", None))
          }
        }
      }
    }
  }

  private def getLinesHtml(): Future[String] = {
    for {
      lines <- lineService.getLines
      bodyString <- Future(lines.map(line => generateLineHTML(line)).mkString("<br>"))
      headerString <- Future(generateHeaderHtml)
      footerString <- Future(generateFooterHtml)
      htmlString <- Future(headerString + bodyString + footerString) // TODO: think about table of contents
    } yield htmlString
  }

  private def generateHeaderHtml: String = {
    """
      |<h1>Lines report</h1>
      |<p>The list of all lines entered to the database is presented below.</p>
    """.stripMargin
  }

  private def generateFooterHtml: String = {
    s"<p>Generated by `moonlight` on ${ZonedDateTime.now()}.</p>"
  }
}
