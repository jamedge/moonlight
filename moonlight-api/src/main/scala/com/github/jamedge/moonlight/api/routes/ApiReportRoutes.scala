package com.github.jamedge.moonlight.api.routes

import java.time.ZonedDateTime

import akka.actor.ActorSystem
import akka.http.scaladsl.model.headers.Accept
import akka.http.scaladsl.model.{ContentTypes, HttpEntity, HttpResponse, MediaTypes, StatusCodes}
import akka.http.scaladsl.server.{Directives, MalformedHeaderRejection, Route}
import com.github.jamedge.moonlight.api.ApiConfig
import com.github.jamedge.moonlight.api.versioning.{FormattedOutputType, HTMLGenerator}
import com.github.jamedge.moonlight.api.versioning.line.LineHTMLSupport.generateLineHTML
import com.github.jamedge.moonlight.api.versioning.line.{LineMDGenerator, LineRoutesSupport}
import com.github.jamedge.moonlight.api.versioning.lineage.GraphFormatter
import com.github.jamedge.moonlight.core.service.line.LineService
import com.github.jamedge.moonlight.core.service.lineage.LineageService

import scala.concurrent.duration._
import scala.concurrent.{Await, ExecutionContext, Future}

class ApiReportRoutes(
    lineService: LineService,
    lineageService: LineageService,
    graphFormatter: GraphFormatter,
    apiConfig: ApiConfig
) (
    implicit val executionContext: ExecutionContext,
    actorSystem: ActorSystem,
    lineMDGenerator: LineMDGenerator,
    htmlGenerator: HTMLGenerator
) extends Directives with LineRoutesSupport {

  def routes: Route = {
    report
  }

  private[routes] def report: Route = {
    path("report") {
      get {
        headerValueByType[Accept]() { accept =>
          if (accept.mediaRanges.exists(_.matches(MediaTypes.`text/html`))) {
            complete(HttpResponse(
              StatusCodes.OK,
              entity = HttpEntity(
                ContentTypes.`text/html(UTF-8)`,
                Await.result(getLinesHtml(), apiConfig.routesLoadTimeoutsMs.report.milliseconds))
            ))
          } else if (accept.mediaRanges.exists(_.matches(MediaTypes.`text/markdown`))) {
            complete(HttpResponse(
              StatusCodes.OK,
              entity = HttpEntity(
                ContentTypes.`text/plain(UTF-8)`,
                Await.result(getLinesMarkdown(), apiConfig.routesLoadTimeoutsMs.report.milliseconds))))
          } else {
            reject(MalformedHeaderRejection("Accept", s"Provided value: ${accept.value()}. Supported values: 'text/html'.", None))
          }
        }
      }
    }
  }

  private def getLinesHtml(): Future[String] = {
    for {
      lines <- lineService.getLines
      bodyString <- Future(lines.map(line => generateLineHTML(line)).mkString("<br>"))
      headerString <- Future(generateHeaderHtml)
      footerString <- Future(generateFooterHtml)
      htmlString <- Future(headerString + bodyString + footerString) // TODO: add table of contents
    } yield htmlString
  }

  private def getLinesMarkdown(): Future[String] = {
    for {
      lines <- lineService.getLines
      linesString <- Future(lines.map(line =>
          lineMDGenerator.
            generateMd(line).
            getOrElse(throw new LineMDGenerationException("Markdown generation failed!"))).mkString("<br>\n"))
      lineageGraphs <- lineageService.getLineageGraphs
      lineagesString <- Future("# Lineage\n" + lineageGraphs.map(graph => graphFormatter.
        formatLineageGraph(graph.graph, graph.rootNode, FormattedOutputType.Md)).mkString("<br><br>\n"))
      headerString <- Future(generateHeaderHtml)
      footerString <- Future(generateFooterHtml)
      htmlString <- Future(
        headerString + "\n" +
          linesString + "\n" +
          lineagesString + "\n" +
          footerString) // TODO: add table of contents
    } yield htmlString
  }

  private def generateHeaderHtml: String = {
    """
      |<h1>Lines report</h1>
      |<p>The list of all lines entered to the database is presented below.</p>
    """.stripMargin
  }

  private def generateFooterHtml: String = {
    s"<p>Generated by `moonlight` on ${ZonedDateTime.now()}.</p>"
  }
}

case class LineMDGenerationException(message: String) extends Exception(message)
